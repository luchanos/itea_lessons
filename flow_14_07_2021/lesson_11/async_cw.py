# Asyncio - фреймворк для создания событийных циклов - реагируем на событие А вызовом функции Б
# asyncio оперирует понятиями тасок (tasks). Поскольку мы отправив запрос не хотим ждать, то нам должны что-то отдать
# в ответ, чтобы мы успокоились. нам отдают "обещание" того, что работа будет сделана. Раньше юзали футуры до появления
# прекрасного asyncio.
# Event loop берет из очереди первую задачу TASK -> в ассоциированной с этой таской корутиной вызывается
# специальный метод и корутина начинает выполнять свой код. Если корутина вызывает другую корутину, то
# объемлющая (делегирующая) корутина приостанавливает своё выполнение. Контроль выполнения переходит к
# вызванной корутине.
# Если корутина вызывает БЛОКИРУЮЩУЮ ФУНКЦИЮ, то она приостанавливает свою работу! Контроль выполнения при этом
# возвращается в событийный цикл. Затем событийный цикл берёт из очереди следующую задачу и т.д. по кругу. Когда
# событийный цикл опять доодит до первой задачи, то ассоциированная с этой таской корутина продолжает свою работу с
# того момента, на котором она остановилась в прошлый раз.

# НАША ЗАДАЧА - описать эти самые корутины, обернуть их в таски и запихнуть в событийный цикл. Когда всё будет
# выполнено, то прикрыть событийный цикл.
import asyncio
from time import time


async def print_nums():
    num = 1
    while True:
        print(num)
        num += 1
        await asyncio.sleep(.5)


async def print_time():
    count = 0
    while True:
        if count % 3 == 0:
            print("{} seconds have passed".format(count))
        count += 1
        await asyncio.sleep(.5)


async def main():
    task_1 = asyncio.create_task((print_nums()))
    task_2 = asyncio.create_task((print_time()))
    await asyncio.gather(task_1, task_2)


if __name__ == '__main__':
    # loop = asyncio.get_event_loop()
    # loop.run_until_complete(main())
    # loop.close()

    # начиная с Python 3.7 можно заменить на:
    asyncio.run(main())
